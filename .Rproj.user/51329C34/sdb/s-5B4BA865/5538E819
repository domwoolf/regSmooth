{
    "contents" : "#' Create divided difference matrix\n#' @param x vector to process\n#' @param d Dimension\n#' @export\n#' @importClassesFrom Matrix dgCMatrix\n#' @importMethodsFrom Matrix diff\n#' @return Output is divided difference matrix for use internally in regSmooth\n#' @keywords internal\ndivided.diff <- function (x, d){\n  m  <- length(x)\n  if (d == 0) {\n    D <- Matrix::sparseMatrix(1:m,  1:m,  x  =  1,  dims  =  c(m,m))}\n  else {\n    dx  <-  x[(d + 1):m] - x[1:(m - d)]\n    dl <- length(dx)\n    V <- Matrix::sparseMatrix(1:dl,  1:dl,  x  =  1/dx,  dims  =  c(dl,dl))\n    D  <-  d * V %*% diff(divided.diff(x, d - 1))}\n  return (D)\n}\n\n\n#' Data smoothing by regularisation.\n#'\n#' Provides data smoothing by Tikhonov regularisation.\n#'\n#' @details\n#' This function is based on the method of Eilers (2003), and its implementation by Stickel (2010).\n#' @param x x values of data to smooth. Numeric vector.If xhat is not supplied, then x must be strictly monotonic increasing.\n#' @param y y values of data to smooth. Numeric vector. Must be same length as x.\n#' @param lambda smoothing parameter (positive real numeric). Higher values give greater smoothing. Smaller values follow data more closely.\n#' @param d Optional order of smoothing derivative. Default=2 (2nd order).\n#' @param xhat An optional numeric vector of x-values to use for the smooth curve. If provided, xhat must be strictly monotonically increasing, and must at least span the data. If xhat is not provided, then the smoothed y values will be have x coordinates at x.\n#' @param w Optional weighting values for fitting each point in the data. Numeric vector. If not provided, then all data points are given equal weighting. Must have same length as x and y.\n#' @param relative Logical (default = False) flag to use relative differences for the goodness of fit term.  Conflicts with the weights (w) optional argument. If relative=True and weights are provided as vector w, then a warning will be issued, and relative set to False.\n#' @param midpr Logical (default = False) flag to use the midpoint rule for the integration terms rather than a direct sum. This option conflicts with the option \"xhat\". If midpr=True and xhat is provided, then a warning will be issued, and midpr set to False.\n#' @importClassesFrom Matrix dgCMatrix\n#' @importMethodsFrom Matrix t diag solve\n#' @export\n#' @return Provides a list of two elements:\n#'  1) yhat = A numeric vector (yhat) of smoothed y values. Vector is of same length as xhat (if provided), or x if not. If xhat is provided, then the smoothed function is given by the data points (xhat,yhat), otherwise, the smoothed curve is (x,yhat).\n#'  2) variance = the variance of the fitted (smoothed model).\n#' @seealso \\code{\\link{regSmoothAuto}}\n#' @references\n#'   Eilers, P., (2003). A Perfect Smoother. anal. chem. 75, 3631-3636.\n#'\n#'   Stickel, J. (2010). Data smoothing and numerical differentiation by a regularization method. Comp. chem. eng. 34.4 467-475.\n#' @author\n#'   Dominic Woolf.\n#'   d.woolf@cornell.edu\n#' @keywords Smoothing\n#' @examples\n#'   x <- 1:1000\n#'   y <- sin(x/100) + 0.3*cos(x/10)                       # Generate a curve\n#'   y.noisy <- y + rnorm(1000, sd=0.1)                    # Add some noise\n#'   y.smoothed <- regSmooth(x=x, y=y.noisy, lambda=1e-6)  # Smooth the noisy data\n#'   plot  (y.noisy ~ x)                                   # Plot noisy data\n#'   lines (y.smoothed$yhat ~ x, col=\"red\", lw=2)     # Draw smoothed curve in red\n#'   lines (y ~ x, col=\"darkgreen\", lw=2, lt=1)       # Original function (without noise) in green\n\nregSmooth <- function (x, y, lambda, d=2, xhat, w, relative, midpr) {\n  # check for required parameters (x, y, and smoothing parameter \"lambda\")\n  if (missing(x)) stop(\"Need to specify x values\")\n  if (missing(y)) stop(\"Need to specify y values\")\n  if (missing(lambda)) stop(\"Need to specify lambda\")\n\n  ## Defaults if not provided\n  #if (missing(d)) d <- 3\n  if (missing(midpr)) midpr <- F\n  xhat.provided  <-  T\n  if (missing(xhat)) {\n    xhat <- x\n    xhat.provided  <-  F}\n  if (xhat.provided & midpr) {\n      warning(\"midpointrule is not implemented if xhat is provided. midpr set to false.\")\n      midpr <- F  }\n  weights.provided <- T\n  if (missing(w)) weights.provided <- F\n  if (missing(relative)) relative <- F\n  if (relative & weights.provided) {\n    warning(\"relative differences are not used if a weighting vector is provided\")\n    relative <- F}\n  N <- length(x)\n  Nhat <- length(xhat)\n\n  if (!(all(diff(xhat)>0))) { #test that x is strict monotonic increasing\n    if (xhat.provided) {\n      stop (\"xhat must be monotonically increasing\")\n      } else {\n        stop (\"x must be monotonically increasing if xhat is not provided\") }}\n\n  # test that xhat spans x\n  if ( (min(x) < min(xhat)) | (max(xhat) < max(x)) )  stop(\"xhat must at least span the data\")\n\n  ########################################\n  # start function proper\n  ########################################\n  M <- Matrix::sparseMatrix(1:N,  1:N,  x  =  1,  dims  =  c(N,N))\n  idx <- unlist(lapply(xhat, function(xi) which.min(abs(xi - x)))) #  for unequally spaced xhat\n  M <- M[,idx]\n  D <- divided.diff(xhat,d)\n\n  ## construct weighting matrices W and U\n  if (weights.provided) { # use weighting provided\n    W <- diag(w)\n  } else {\n    if (relative) {\n      yl <- length(y)\n      Yinv <- Matrix::sparseMatrix(1:yl,  1:yl,  x  =  1/y,  dims  =  c(yl,yl))\n      W <- Yinv^2\n    } else {\n      W <- Matrix::sparseMatrix(1:N,  1:N,  x  =  1,  dims  =  c(N,N))\n      }\n    }\n\n  if (midpr) { ## use midpoint rule integration (rather than simple sums)\n    Bhat <- Matrix::Matrix(0,nrow=N,ncol=N)\n    Bhat[1:N-1,2:N] <- Matrix::Diagonal(N-1)\n    Bhat[2:N,1:N-1] <- Bhat[2:N,1:N-1]-Matrix::Diagonal(N-1)\n    Bhat[1,1] <- -1\n    Bhat[N,N] <- 1\n    B <- Matrix::sparseMatrix(1:N, 1:N, x = (Bhat %*% x)/2, dims=c(N,N))\n    if ( floor(d/2) == d/2 ) { # test if d is even\n      dh <- d/2\n      Btilda <- B[(dh+1):(N-dh) , (dh+1):(N-dh)]\n      } else { # d is odd\n        dh <- ceiling(d/2)\n        Btilda <- B[dh:(N-dh) , dh:(N-dh)]  }\n    W <- W%*%B\n    U <- Btilda\n  } else {\n    # W = W*speye(Nhat)\n    U <- Matrix::sparseMatrix(1:(Nhat-d),  1:(Nhat-d),  x  =  1,  dims  =  c((Nhat-d),(Nhat-d)))\n    }\n\n  ## Do the smoothing\n  delta <- sum(Matrix::diag(Matrix::t(D)%*%D)) / Nhat^(2+d)\n  yhatA <- (Matrix::t(M)%*%W%*%M + lambda*delta^(-1)*Matrix::t(D) %*% U %*% D)\n  yhatB <- Matrix::t(M)%*%W%*%y\n  yhat <- solve(yhatA) %*% yhatB\n  H1 = Matrix::t(M)%*%W%*%M + (lambda/delta)*Matrix::t(D)%*%U%*%D\n  H = M %*% ((solve(H1) %*% Matrix::t(M)) %*% W)\n  v = Matrix::t(M%*%yhat - y) %*% (M%*%yhat - y) / N / (1 - sum(Matrix::diag(H))/N)^2\n  return(list(yhat=yhat[,1], variance=v[1,1]))\n}\n\n\n#' Data smoothing by regularisation.\n#'\n#' Function to smooth data using Tikhonov regularisation,\n#' with optional optimisation of the regularisation parameter by generalised cross validation.\n#' @details\n#' This function is based on the method of Eilers (2003), and its implementation by Stickel (2010).\n#' @param x x values of data to smooth. Numeric vector.If xhat is not supplied, then x must be strictly monotonic increasing.\n#' @param y y values of data to smooth. Numeric vector. Must be same length as x.\n#' @param lambda smoothing parameter (positive real numeric). Higher values give greater smoothing. Smaller values follow data more closely.\n#' @param d Optional order of smoothing derivative. Default=2 (2nd order derivatives).\n#' @param relative Logical (default = False) flag to use relative differences for the goodness of fit term.  Conflicts with the weights (w) optional argument. If relative=True and weights are provided as vector w, then a warning will be issued, and relative set to False.\n#' @param midpr Logical (default = False) flag to use the midpoint rule for the integration terms rather than a direct sum. This option conflicts with the option \"xhat\". If midpr=True and xhat is provided, then a warning will be issued, and midpr set to False.\n#' @param maxit Maximum number of iterations to use when solving for lambda.\n#' @param guess.lambda Starting value for lambda optimisation.\n#' @param ... Additional optional parameters to pass to regSmooth:\n#' w =  Optional weighting values for fitting each point in the data (numeric vector). If not provided, then all data points are given equal weighting. Must have same length as x and y.\n#' xhat = An optional numeric vector of x-values to use for the smooth curve. If provided, xhat must be strictly monotonically increasing, and must at least span the data. If xhat is not provided, then the smoothed y values will be have x coordinates at x.\n#' @export\n#' @return Provides a list of two elements:\n#'  1) yhat = A numeric vector (yhat) of smoothed y values. Vector is of same length as xhat (if provided), or x if not. If xhat is provided, then the smoothed function is given by the data points (xhat,yhat), otherwise, the smoothed curve is (x,yhat).\n#'  2) variance = the variance of the fitted (smoothed model).\n#' @seealso \\code{\\link{regSmooth}}\n#' @references\n#'   Eilers, P. (2003). A Perfect Smoother. Anal. chem. 75, 3631-3636.\n#'\n#'   Stickel, J. (2010). Data smoothing and numerical differentiation by a regularization method. Comp. chem. eng. 34.4 467-475.\n#' @author\n#'   Dominic Woolf.\n#'   d.woolf@cornell.edu\n#' @keywords Smoothing\n#' @examples\n#'   x <- 1:1000\n#'   y <- sin(x/100) + 0.3*cos(x/10)              # Generate a curve\n#'   y.noisy <- y + rnorm(1000, sd=0.1)           # Add some noise\n#'   y.smoothed <- regSmoothAuto(x=x, y=y.noisy)  # Smooth the noisy data\n#'   plot  (y.noisy ~ x)                          # Plot the noisy data\n#'   lines (y.smoothed$yhat ~ x, col=\"red\", lw=2) # Draw the smoothed curve in red\n#'   lines (y ~ x, col=\"darkgreen\", lw=2, lt=1)   # Original function (without noise) in green\n\nregSmoothAuto <- function (x, y, lambda, d=2, relative=F, midpr=F, maxit=1000, guess.lambda=1e-3, ...){\n  payoff <- function(try.lambda){\n    return(regSmooth(x=x, y=y, lambda=try.lambda, relative=relative, midpr=midpr)$variance)\n  }\n  if (missing(lambda)) {# solve for optimal lambda if user-defined value not provided\n    lambda <- nlm(f=payoff, p=guess.lambda, iterlim=maxit)$estimate\n  }\n  smooth.result  <-  regSmooth(x=x, y=y, d=d, lambda=lambda, relative=relative, midpr=midpr,...)\n  return (list(yhat=smooth.result$yhat, lambda=lambda, variance=smooth.result$variance))\n}\n",
    "created" : 1459533076002.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3734006943",
    "id" : "5538E819",
    "lastKnownWriteTime" : 1463683664,
    "path" : "C:/Users/Dominic/Box Sync/scripts etc/regSmooth/R/regSmooth1.1.R",
    "project_path" : "R/regSmooth1.1.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}